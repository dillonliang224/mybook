# linux

[toc]

## 05: 学会几个系统调用

### 进程管理

创建进程的系统调用叫fork。

在linux里，要创建一个新的进程，需要一个老的进程调用fork来实现，其中老的进程叫做父进程(Parent Process)，新的进程叫做子进程(Child Process)。

当父进程调用fork创建进程的时候，子进程将各个子系统为父进程创建的数据结构也全部拷贝了一份，甚至连程序代码也是拷贝过来的。

对于fork系统调用的返回值，如果当前进程是子进程，就返回0；如果当前进程是父进程，就返回子进程的进程号。

需要注意的是，如果是父进程，还接着做原来应该做的事情；如果是子进程，需要请求另一个系统调用**execve**来执行另一个程序，这个时候，子进程和父进程就彻底分道扬镳了，也就产生了一个分支(fork)了。这也是为什么创建进程的系统调用叫fork的原因。

怎么关注子进程的运行情况呢？可以通过系统调用**waitpid**，将子进程的进程号作为参数传给它，这样父进程就知道子进程运行完了没有，成功与否。

### 内存管理

对于进程的内存空间来讲，放程序代码的这部分，称为代码段（Code Segment），放进程运行中产生数据的这部分，称为数据段（Data Segment）

产生的数据中，其中局部变量的部分，在当前函数执行的时候起作用，当进入另一个函数时，这个变量就释放了；也有动态分配的，会较长时间保存，指明才销毁，这部分称为堆（Heap）

在堆里面分配内存的系统调用有两个：
- brk: 分配内存数量比较小的时候，会和原来的堆的数据连在一起
- mmap: 分配内存数量比较大的时候，会重新划分一块内存区域

### 文件系统调用

- 对于已经有的文件，可以使用**open**打开这个文件，**close**关闭这个文件；
- 对于没有的文件，可以使用**creat**创建文件；
- 打开文件以后，可以使用**lseek**跳到文件的某个位置；
- 可以对文件的内容进行读写，读的系统调用是read，写是write

### 文件描述符
File Descriptor，是一个整数。有了这个文件描述符，我们就可以使用系统调用，查看或者干预进程运行的方方面面。

### 信号处理

信号处理服务，提供了一种通知机制，当收到信号时，可以对系统做对应的处理。linux提供了系统调用**sigaction**，用于注册一个信号处理函数。

- SIGKILL: 用于终止一个进程的信号
- SIGSTOP: 用于中止一个进程的信号


### 进程间通信

1. 小消息，通过消息队列进行通信。在内核里通过**msgget**创建一个新的队列，**msgsnd**将消息发送到消息队列，消息接收方可以使用**msgrcv**从队列中取消息。
2. 大信息，通过共享内存进行通信。通过**shmget**创建一个共享内存块，通过**shmat**将共享内存映射到自己的内存空间，然后进行读写。

共享内存会存在“竞争”的问题，linux通过信号量的机制Semaphore处理，即调用**sem_wait**占用这个信号量，用**sem_post**将信号量释放，当信号量被占用的时候，其他进程无法访问这块内存数据，直到某一进程获取该信号量。

### 网络通信

不同机器通过网络相互通信，要遵循相同的网络协议，也即TCP/IP网格协议栈。Linux内核里有对于网络协议栈的实现。如何暴露出服务呢？

网络服务是通过套接字Socket来提供服务的。Socket这个名字很有意思，可以作为“插口”或者“插槽“讲。可以想象成弄一个网线，一头插在客户端，一头插在服务端，然后进行通信。因此，在通信之前，双方都要建立一个Socket。

### Glibc

Glibc是linux下使用的开源的标准C库，它为程序员提供了丰富的API，封装了操作系统提供的系统服务，即系统调用的封装。

### strace

linux命令，常用来跟踪进程执行时系统调用和接受的信号。

