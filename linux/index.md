# linux

[toc]

## 04: 快速上手几个Linux命令

### 用户与密码

- **useradd** dillon: 创建一个名为dillon的用户
- **passwd** dillon: 修改dillon的密码

### 浏览文件

在linux下用ls浏览文件，ls means list。

```sh
ls -l

-rw-r--r--   1 dillonliang  staff   290  5  8 21:56 book.json
drwxr-xr-x   4 dillonliang  staff   128  8 15  2019 demo
```

1. 第一个字段的第一个字符是文件类型，"-"代表普通文件，“d”代表目录，剩下9个字符是模式，3个一组，每一组rwx表示“读（read）”，“写（write）”，“执行（execute）”。这三组分别表示文件所属的用户权限、文件所属的组权限以及其他用户权限。如果想改变权限，可以使用命令*chmod 711 demo*
2. 第二个字段是硬链接数目
3. 第三个字段是所属用户
4. 第四个字段是所属组
5. 第五个字段是文件的大小
6. 第六个字段是文件被修改的日期
7. 第七个字段是文件名

可以通过命令**chown**改变所属用户，**chgrp**改变所属组

### 后台运行

使用**nohup**命令，意思是no hang up(不挂起)，也就是说，当前交互命令行退出的时候，程序还要在。
> nohup command >out.file 2>&1 &

- ”1“表示文件描述符，表示标准输出
- “2”表示文件描述符，表示错误输出
- “2>&1”表示标准输出和错误输出合并了，输出到out.file里
- 最后的“&”，表示后台运行，不占用交互命令行

如果关闭这个进程呢？假设启动的程序中包含某个关键字，那么可以使用下面的命令：
> ps -ef | grep 关键字 | awk '{print $2}' | xargs kill -9

### 服务运行

使用**systemctl start xxx**和**systemctl enable xxx**来启动服务和设置开机启动

### 开机和重启

- shutdown -h now: 现在就关机
- reboot: 重启

## 05: 学会几个系统调用

### 进程管理

创建进程的系统调用叫fork。

在linux里，要创建一个新的进程，需要一个老的进程调用fork来实现，其中老的进程叫做父进程(Parent Process)，新的进程叫做子进程(Child Process)。

当父进程调用fork创建进程的时候，子进程将各个子系统为父进程创建的数据结构也全部拷贝了一份，甚至连程序代码也是拷贝过来的。

对于fork系统调用的返回值，如果当前进程是子进程，就返回0；如果当前进程是父进程，就返回子进程的进程号。

需要注意的是，如果是父进程，还接着做原来应该做的事情；如果是子进程，需要请求另一个系统调用**execve**来执行另一个程序，这个时候，子进程和父进程就彻底分道扬镳了，也就产生了一个分支(fork)了。这也是为什么创建进程的系统调用叫fork的原因。

怎么关注子进程的运行情况呢？可以通过系统调用**waitpid**，将子进程的进程号作为参数传给它，这样父进程就知道子进程运行完了没有，成功与否。

### 内存管理

对于进程的内存空间来讲，放程序代码的这部分，称为代码段（Code Segment），放进程运行中产生数据的这部分，称为数据段（Data Segment）

产生的数据中，其中局部变量的部分，在当前函数执行的时候起作用，当进入另一个函数时，这个变量就释放了；也有动态分配的，会较长时间保存，指明才销毁，这部分称为堆（Heap）

在堆里面分配内存的系统调用有两个：
- brk: 分配内存数量比较小的时候，会和原来的堆的数据连在一起
- mmap: 分配内存数量比较大的时候，会重新划分一块内存区域

### 文件系统调用

- 对于已经有的文件，可以使用**open**打开这个文件，**close**关闭这个文件；
- 对于没有的文件，可以使用**creat**创建文件；
- 打开文件以后，可以使用**lseek**跳到文件的某个位置；
- 可以对文件的内容进行读写，读的系统调用是read，写是write

### 文件描述符
File Descriptor，是一个整数。有了这个文件描述符，我们就可以使用系统调用，查看或者干预进程运行的方方面面。

### 信号处理

信号处理服务，提供了一种通知机制，当收到信号时，可以对系统做对应的处理。linux提供了系统调用**sigaction**，用于注册一个信号处理函数。

- SIGKILL: 用于终止一个进程的信号
- SIGSTOP: 用于中止一个进程的信号


### 进程间通信

1. 小消息，通过消息队列进行通信。在内核里通过**msgget**创建一个新的队列，**msgsnd**将消息发送到消息队列，消息接收方可以使用**msgrcv**从队列中取消息。
2. 大信息，通过共享内存进行通信。通过**shmget**创建一个共享内存块，通过**shmat**将共享内存映射到自己的内存空间，然后进行读写。

共享内存会存在“竞争”的问题，linux通过信号量的机制Semaphore处理，即调用**sem_wait**占用这个信号量，用**sem_post**将信号量释放，当信号量被占用的时候，其他进程无法访问这块内存数据，直到某一进程获取该信号量。

### 网络通信

不同机器通过网络相互通信，要遵循相同的网络协议，也即TCP/IP网格协议栈。Linux内核里有对于网络协议栈的实现。如何暴露出服务呢？

网络服务是通过套接字Socket来提供服务的。Socket这个名字很有意思，可以作为“插口”或者“插槽“讲。可以想象成弄一个网线，一头插在客户端，一头插在服务端，然后进行通信。因此，在通信之前，双方都要建立一个Socket。

### Glibc

Glibc是linux下使用的开源的标准C库，它为程序员提供了丰富的API，封装了操作系统提供的系统服务，即系统调用的封装。

### strace

linux命令，常用来跟踪进程执行时系统调用和接受的信号。

