# MySQL实战

## 基础架构：一条SQL查询语句是如何执行的？

### MySQL的基本架构示意图：

![](https://static001.geekbang.org/resource/image/0d/d9/0d2070e8f84c4801adbfa03bda1f98d9.png)

大体来说，MySQL 可以分为 Server 层和存储引擎层两部分。

Server 层包括连接器、查询缓存、分析器、优化器、执行器等，涵盖 MySQL 的大多数核心服务功能，以及所有的内置函数（如日期、时间、数学和加密函数等），所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图等。

而存储引擎层负责数据的存储和提取。其架构模式是插件式的，支持 InnoDB、MyISAM、Memory 等多个存储引擎。现在最常用的存储引擎是 InnoDB，它从 MySQL 5.5.5 版本开始成为了默认存储引擎。

### 连接器

连接数据库，输入账户密码，如果用户名或密码不对

多个连接不释放会导致mysql内存吃紧，怎么解决这个问题呢？

- 定期断开长连接。使用一段时间，或者程序里面判断执行过一个占用内存大大查询后，断开连接，之后要查询再连接。

- 如果mysql版本>=5.7，可以通过执行mysql_reset_connection来重新初始化连接资源。这个过程不需要重连和重新做权限验证，但是会将连接恢复到刚刚创建完时的状态。

### 查询缓存（8.0之后删除）

在上图中，查询缓存的功能在MySQL8.0版本被删除了，之前的版本大多数情况下也不建议使用查询缓存，如果表中有数据更新，会把表上所有的查询缓存都会被清空，缓存命中率低。

### 分析器

先经过词法分析，识别出SQL语句里的字符串分别是什么，代表什么。

再经过语法分析，判断输入的SQL语句是否满足MySQL语法。

如果语句不对，就会收到*You have an error in your SQL syntax*的错误提醒。

### 优化器

经过了分析器，MySQL就知道你要做什么了，在开始执行之前，还要先经过优化器的处理。

优化器是在表里面有多个索引的时候，决定使用哪个索引；或者在一个语句有多表关联（join）的时候，决定各个表的连接顺序。

### 执行器

MySQL 通过分析器知道了你要做什么，通过优化器知道了该怎么做，于是就进入了执行器阶段，开始执行语句。

开始执行的时候，要先判断一下你对这个表 T 有没有执行查询的权限，如果没有，就会返回没有权限的错误，如下所示 (在工程实现上，如果命中查询缓存，会在查询缓存返回结果的时候，做权限验证。查询也会在优化器之前调用 precheck 验证权限)。

```sql
mysql> select * from T where ID=10;

ERROR 1142 (42000): SELECT command denied to user 'b'@'localhost' for table 'T'
```

## 日志系统：一条SQL更新语句是如何执行的？

### 重要的日志模块：redo log

MySQL里经常说到的WAL技术，WAL的全称是Write-Ahead Logging，它的关键点就是先写日志，再写磁盘。

具体来说，当有一条记录需要更新的时候，InnoDB 引擎就会先把记录写到 redo log里面，并更新内存，这个时候更新就算完成了。同时，InnoDB 引擎会在适当的时候，将这个操作记录更新到磁盘里面，而这个更新往往是在系统比较空闲的时候做，这就像打烊以后掌柜做的事。

redo log是固定大小的。

有了 redo log，InnoDB 就可以保证即使数据库发生异常重启，之前提交的记录都不会丢失，这个能力称为 crash-safe。

### 重要的日志模块：binlog

因为最开始 MySQL 里并没有 InnoDB 引擎。MySQL 自带的引擎是 MyISAM，但是 MyISAM 没有 crash-safe 的能力，binlog 日志只能用于归档。而 InnoDB 是另一个公司以插件形式引入 MySQL 的，既然只依靠 binlog 是没有 crash-safe 能力的，所以 InnoDB 使用另外一套日志系统——也就是 redo log 来实现 crash-safe 能力。

这两种日志有以下三点不同。

redo log 是 InnoDB 引擎特有的；binlog 是 MySQL 的 Server 层实现的，所有引擎都可以使用。redo log 是物理日志，记录的是“在某个数据页上做了什么修改”；binlog 是逻辑日志，记录的是这个语句的原始逻辑，比如“给 ID=2 这一行的 c 字段加 1 ”。redo log 是循环写的，空间固定会用完；binlog 是可以追加写入的。“追加写”是指 binlog 文件写到一定大小后会切换到下一个，并不会覆盖以前的日志。

执行器执行的时候，会采用**两阶段提交**的方式。

![](https://static001.geekbang.org/resource/image/2e/be/2e5bff4910ec189fe1ee6e2ecc7b4bbe.png)

1. 先写redo log，处于prepare阶段

2. 再写binlog，mysql记录逻辑日志

3. 提交事务，继续写redo log，完成更新。

如果1执行后，mysql崩溃，那么重启后发现没有commit, 回滚。备份恢复：没有binlog，一致。

如果2执行后，mysql崩溃，虽然没有commit,但prepare和binlog完整，重启后自动commit。备份：有binlog，一致。

## 事务隔离

事务就是要保证一组数据库操作，要么全部成功，要么全部失败。在MySQL中，事务支持是在引擎层实现的。MySQL是一个支持多引擎的系统，但并不是所有的引擎都支持事务。比如MySQL原生的MyISAM引擎就不支持事务。

ACID：

- Atomicity: 原子性

- Consistency: 一致性

- Isolation: 隔离性

- Durability: 原子性

当数据库上有多个事务同时执行的时候，就可能出现脏读、不可重复读、幻读的问题，为了解决这些问题，就有了隔离级别的概念。

隔离级别；

- 读未提交：一个事务还没提交，它做的变更就能被别的事务看到。

- 读提交：一个事务提交之后，它做的变更才会被其他事务看到。

- 可重复读：一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据一致的 。

- 串行化：顾名思义是对于同一行记录，“写”会加“写锁”，“读”会加“读锁”。当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。

RC级别下，MVCC视图会在每一个语句前创建一个，所以在RC级别下，一个事务是可以看到另外一个事务已经提交的内容，因为它在每一次查询之前都会重新给予最新的数据创建一个新的MVCC视图。 RR级别下，MVCC视图是在开始事务的时候就创建好了，这个视图会一直使用，直到该事务结束。 这里要注意不同的隔离级别他们的一致性事务视图创建的时间点是不同的。 RU：没有视图的概念，直接返回最小行数据。 RC：在每一行SQL语句执行的时候创建。 RR：在事务启动的时候创建。 Serial：通过锁来实现数据访问，没有视图的概念。

### 长事务

长事务意味着系统里面会存在很老的事务视图。由于这些事务随时可能访问数据库里面的任何数据，所以这个事务提交之前，数据库里面它可能用到的回滚记录都必须保留，这就会导致大量占用存储空间。

```sql
## 把线程的自动提交关掉，事务持续存在，直到主动commit或rollback，或断开连接
set autocommit=0
```

建议使用set autocommit=1，通过显式语句的方式来启动事务。

在 autocommit 为 1 的情况下，用 begin 显式启动的事务，如果执行 commit 则提交事务。如果执行 commit work and chain，则是提交事务并自动启动下一个事务，这样也省去了再次执行 begin 语句的开销。同时带来的好处是从程序开发的角度明确地知道每个语句是否处于事务中。

你可以在 information_schema 库的 innodb_trx 这个表中查询长事务，比如下面这个语句，用于查找持续时间超过 60s 的事务。

```sql
select * from information_schema.innodb_trx where TIME_TO_SEC(timediff(now(),trx_started))>60
```

## 深入浅出索引（上）

### 索引的常见模型

常见模型：哈希表、有序数组和搜索树

哈希表通过对key做hash运算得到一个值，这个值也可以称为桶ID，把对应的value放入对应的桶。不同的key可能经过hash运算得到相同的值，所以经常有哈希冲突的问题。为了解决哈希冲突，会在存放值的地方用链表存储值。

**哈希表这种结构适用于只有等值查询的场景**，而对范围查找，有心无力，需要全表扫描。

**有序数组在等值查询和范围查询场景中的性能就都非常优秀**。但对插入数据和删除数据比较麻烦，需要挪动更新数据之后的所有记录，成本太高。

所以，有序数组索引只适用于静态存储引擎。

二叉搜索树的特点是：父节点左子树所有结点的值小于父节点的值，右子树所有结点的值大于父节点的值。查找和更新的时间复杂度都是O(log(N))。

### InnoDB的索引模型

在InnoDB中，表都是根据主键顺序以索引的形式存放的，这种存储方式的表称为索引组织表。InnnoDB使用了B+树索引模型，所以数据都是存储在B+树中的。

每一个索引在InnoDB里面对应一个B+树。

B+树能够很好地配合磁盘的读写特性，减少单次查询的磁盘访问次数。

索引类型：

- 主键索引（聚簇索引）

- 非主键索引（二级索引）

非主键索引的叶子节点内容是主键的值，主键索引叶子节点内容是对应的数据。

所以基于非主键索引的查询需要先找到对应的主键，然后通过主键找多对应的值，非主键索引的查询需要多扫描一个索引树，这个过程称为**回表**。

### 索引维护

B+树为了维护索引有序性，在插入新值或删除数据时，会发生页的分裂和合并过程。

一般情况下都是采用自增主键的形式插入数据，这只会涉及到追加操作，都不涉及到挪动其他记录，也不会触发叶子节点的分裂。  

而有业务逻辑的字段做主键，则往往不容易保证有序插入，这样写数据成本相对较高。

在索引创建过程中，**主键长度越小，普通索引的叶子节点就越小，普通索引占用的空间也就越小**，所以从性能和存储空间方面考量，自增主键往往是更合理的选择。  

当然，如果是典型的K/V场景，直接使用k作为主键，可以避免每次查询需要搜索两棵树。   

“N叉树”的N值在MySQL中是可以被人工调整的么？

1， 通过改变key值来调整  
N叉树中非叶子节点存放的是索引信息，索引包含Key和Point指针。Point指针固定为6个字节，假如Key为10个字节，那么单个索引就是16个字节。如果B+树中页大小为16K，那么一个页就可以存储1024个索引，此时N就等于1024。我们通过改变Key的大小，就可以改变N的值  
2， 改变页的大小  
页越大，一页存放的索引就越多，N就越大。

数据页调整后，如果数据页太小层数会太深，数据页太大，加载到内存的时间和单个数据页查询时间会提高，需要达到平衡才行。

## 深入浅出索引（下）

### 覆盖索引

由于覆盖索引可以减少树的搜索次数，显著提升查询性能，所以使用覆盖索引是一个常用的性能优化手段。



当然，索引在数据中也是有代价的，不是索引越多越好。因此，在建立冗余索引来支持覆盖索引时就需要权衡考虑了



### 最左前缀原则

B+树这种索引结构，可以利用索引的“最左前缀”，来定位记录。

索引项是按照索引定义里面出现的字段顺序排序的。

**只要满足最左前缀，就可以利用索引来加速检索。这个最左前缀可以是联合索引的最左N个字段，也可以是字符串索引的最左M个字符**。



在建立联合索引的时候，如何安排索引内的字段顺序？

1。如果通过调整顺序，可以少维护一个索引，那么这个顺序就是需要优先考虑采用的。

2。索引使用的空间大小。



### 索引下推

MySQL5.6引入索引下推优化（index condition pushdown），可以在索引遍历过程中，对索引包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数。



## 全局锁和表锁：给表加个字段怎么有这么多阻碍？

数据库锁设计的初衷是处理并发问题。作为多用户共享的资源，当出现并发访问的时候，数据库需要合理地控制资源的访问规则。而锁就是用来实现这些规则的重要数据结构。



锁类型：

- 全局锁

- 表级锁

- 行锁



### 全局锁

顾名思义，全局锁就是对整个数据库实例加锁。

```sql
// 命令（FTWRL）
Flush tables with read lock
```

执行完命令后，数据库进入只读状态。

全局锁的典型使用场景是，做全库逻辑备份。



官方自带逻辑备份工具**mysqldump**。当 mysqldump 使用参数–single-transaction 的时候，导数据之前就会启动一个事务，来确保拿到一致性视图。而由于 MVCC 的支持，这个过程中数据是可以正常更新的。（只适用于支持事务的引擎表）



MySQL里如果要实现全库只读，还有set global readonly=true的方式，也可以让全库进入只读状态。但一般建议使用FTWRL方式，原因如下：

- 在有些系统中，readonly的值会被用来做其他逻辑，比如用来判断一个库是主库还是备库。因此，修改global变量的方式影响面更大，不建议使用。

- 在异常处理机制上有差异。如果执行FTWRL命令之后客户端发生异常断开，那么MySQL会自动释放这个全局锁，整个库回到可以正常更新的状态。而将整个库设置为readonly之后，如果客户端发生异常，则数据库就会一直保持readonly状态，这样会导致整个库长时间处于不可写状态，风险较高。





### 表级锁

MySQL里面表级别的锁有两种：**一种是表锁，一种是元数据锁（meta data lock, MDL）。**



表锁语法是： **lock tables ... read/write**, 与FTWRL类似，可以用unlock tables主动释放锁，也可以在客户端断开的时候自动释放。



在MySQL5.5版本引入了MDL，当对一个表做增删改查操作的时候，加MDL读锁；当要对表做结构变更操作的时候，加MDL写锁。

- 读锁之间不互斥，因此可以有多个线程同时对一张表增删改查

- 读写锁之间、写锁之间是互斥的，用来保证变更表结构操作的安全性。因此，如果有两个线程同时给一个表加字段，其中一个要等另一个执行完才能开始执行。



事务中的MDL锁，在语句执行开始时申请，但是语句结束后并不会马上释放，而会等到整个事务提交后再释放。即使修改一个小表，也可能拉垮整个数据库。



如何安全地给小表加字段呢？采用如下命令：

```sql
ALTER TABLE tbl_name NOWAIT add column ...
ALTER TABLE tbl_name WAIT N add column ...
```

可以指定等待时间，如果在给定时间内未获取MDL写锁，先放弃，不阻塞后面的业务语句。之后开发人员或者DBA再通过重试命令重复这个过程。





## 行锁功过：怎么减少行锁对性能的影响？

MySQL的行锁是在引擎层由各个引擎自己实现的。顾名思义，行锁就是针对数据表中行记录的锁。



### 两阶段锁



**在InnoDB事务中，行锁是在需要的时候才加上的，但并不是不需要了就立刻释放，而是要等到事务结束时才释放。这个就是两阶段锁协议。**



**如果你的事务中需要多个行，要把最可能造成锁冲突、最可能影响并发度的锁尽量往后放。**



### 死锁和死锁检测

当并发系统中不同线程出现循环资源依赖，涉及的线程都在等待别的线程释放资源时，就会导致这几个线程都进入无限等待的状态，称为死锁。



当出现死锁以后，有两种策略：

- 一种策略是，直接进入等待，直到超时。这个超时时间可以通过参数innodb_lock_wait_timeout来设置。

- 另一种策略是，发起死锁检测，发现死锁后，主动回滚死锁链条中的某一个事务，让其他事务得以继续执行。将参数innodb_deadlock_detect设置为on表示开起这个逻辑。



## 事务到底是隔离的还是不隔离的？



当前读：更新数据都是先读后写的，而这个读，只能读当前的值，称为“当前读”（current read）。

以下两条语句也是当前读：

```sql
// 加读锁
select k from t where id=1 lock in share mode;
// 加写锁
select k from t where id=1 for update;
```

当前读，读的永远是数据库里最新的值。



---

InnoDB的行数据有多个版本，每个数据版本有自己的row_trx_id，每个事务或者语句有自己的一致性视图。普通查询语句是一致性读，一致性读会根据row_trx_id和一致性视图确定数据版本的可见性。

- 对于可重复读，查询只承认在事务启动前就已经提交完成的数据；

- 对于读提交，查询只承认在语句启动前就已经提交完成读数据；



而当前读，总是读取已经提交完成的最新版本。



## 普通索引和唯一索引，应该怎么选择？



redo log主要节省的是随机写磁盘的IO消耗（转成顺序写）

change buffer主要节省的则是随机读磁盘的IO消耗。



由于唯一索引用不上change buffer的优化机制，因此如果业务可以接受，从性能角度出发，优先考虑普通索引。

change buffer可以看成也是一个数据页，需要被持久化到系统表空间（ibdata1），以及把这个change buffer页的改动记录在redo log里，事后刷进系统表空间。

将change buffer中的操作应用到原数据页，得到最新结果的过程称为merge。除了访问这个数据页会触发merge外，系统有后台线程会定期merge。在数据库正常关闭（shutdown）的过程中，也会执行merge操作。



QA：

1。 如果某次写入使用了change buffer机制，之后主机异常重启，是否会丢失change buffer和数据。

-》不会丢失，事务提交的事后，MySQL会把change buffer的操作也记录到redo log里了，所以崩溃恢复的时候，change buffer也能找回来。

2。 merge的执行流程

> 1. 从磁盘读入数据页到内存（老版本的数据页）；
> 
> 2. 从change buffer里找出这个数据页的change buffer记录（可能有多个），依次应用，得到新版数据页；
> 
> 3. 写redo log。这个redo log包含了数据的变更和change buffer的变更。

到这里merge过程结束了。这时候，数据页和内存页change buffer对应的磁盘位置都还没有修改，属于脏页，之后各自刷回自己的物理数据，就是另外一个过程了。



---

## MySQL为什么有时候会选错索引？

选择索引是优化器的工作。

而优化器选择索引的目的，是找到一个最优的执行方案，并用最小的代价去执行语句。在数据库里面，扫描行数是影响执行代价的因素之一。扫描的行数越少，意味着访问磁盘数据的次数越少，消耗的CPU资源越少。

当然，扫描行数并不是唯一的判断标准，优化器还会结合是否使用临时表，是否排序等因素进行综合判断。

对于由于索引信息不准确导致的问题，可以使用analyze table来解决。



### 索引选择异常和处理

第一种方式是，采用force index强行选择一个索引。

第二种方法是，修改语句，引导MySQL使用我们期望的索引。

第三种方法是，在有些场景下，我们可以新建一个更合适的索引，来提供给优化器做选择，或删掉误用的索引。





## 怎么给字符串字段加索引？

字符串可以定义一部分作为索引，也可以全部字符串作为索引。

```sql
alter table t add index index1(email);
alter table t add index index2(email(6));
```

第一个是全部索引，第二个是前6个字符串索引。

可以使用前缀索引，定义好长度，就可以做到既节省空间，又不用额外增加太多的查询成本。



so, 创建字符串索引的方式有：

1。 直接创建完整索引，这样可能比较占用空间；

2。 创建前缀索引，节省空间，但会增加查询扫描次数，并且不能使用覆盖索引；

3。 倒序索引，再创建前缀索引，用于绕过字符串本身前缀的区分度不够的问题；

4。 创建hash字段索引，查询性能稳定，有额外的存储和计算开销，跟第三种方式一样，都不支持范围扫描。



## 为什么我的MySQL会抖一下？

[12 | 为什么我的MySQL会“抖”一下？-极客时间](https://time.geekbang.org/column/article/71806)
