# 内存管理

CPU如果直接操作内存的物理地址，那么多个进程间会相互影响。

进程可以相互修改内存，也可能修改操作系统的内存，没有隔离性。



CPU线性地址到物理地址的转换，会交由CPU中MMU（内存管理单元）负责。

当前CPU持有的页目录地址会保存到特定寄存器。





所以操作系统为每个进程分配独立的一套**虚拟地址**

## 虚拟内存

>  操作系统会提供一种机制，将不同进程的虚拟地址和不同内存的物理地址映射起来。

如果程序要访问虚拟地址的时候，由操作系统转换成不同的物理地址，这样不同的进程运行的时候，写入的是不同的物理地址，这样就不会冲突了。

### 操作系统是如何管理虚拟地址与物理地址之间的关系？

主要通过**内存分段**和内存分页。

#### 内存分段

程序是由若干逻辑分段组成的，如可由代码分段、数据分段、栈段、堆段组成。不同的段是有不同的属性的，所以就用分段（Segmentation）的形式把这些段分离出来。

分段机制下的虚拟地址由两部分组成，*段选择因子*和*段内偏移量*。

#### 内存分页

分页是把整个虚拟和物理内存空间切成一段段固定尺寸的大小，这样一个连续并且尺寸固定的内存空间，我们叫页（Page）。在linux下，每一页的大小为4KB。

虚拟地址和物理地址之间通过页表来映射。

而当进程访问的虚拟地址在页表中查不到时，系统会产生一个**缺页异常**，进行系统内核空间分配物理内存、更新进程页表，最后再返回用户空间，恢复进程的运行。



页目录 -> 页表 -> 物理内存页

```bash
1024 * 1024 * 4kb = 4G
```



线性地址（32位下，一个内存地址占4个字节）

```bash
0000000000 00000000000 XXXXXXXXXXXX
对应页表    对应物理内存页 相对于内存起始地址的偏移值            
```



2^12bit = 4096bit = 4kb，12位正好覆盖4kb个偏移值，也就足够定位到这一页的每一个地址了（一页大小为4KB）



实现了一个虚拟内存页到物理内存页的映射。

映射为不同的物理内存页，可以实现进程间的隔离。

映射为相同的物理内存页，可以实现进程间的共享。



#### 多级页表/页表缓存

TLB（Translation Lookaside Buffer）缓存记录线性地址到物理地址的映射。

先查TLB，如果没有的话，查页表写入TLB。

如果发生了进程切换，寄存器存储的页目录地址需要改变，TLB缓存也会失效，需要重新查询页表，建立新的缓存数据，这也是进程切换代价比较高的一个原因。



如果CPU查询页表时发现，对应物理内存页还没有完成映射，会发生page fault（缺页异常），这时查看进程是否分配了这块物理地址，如果分配了，完成映射，如果没有分配，保内存异常错误。





---

参考总结：

- https://mp.weixin.qq.com/s/HJB_ATQFNqG82YBCRr97CA
- https://mp.weixin.qq.com/s?__biz=Mzg5NjIwNzIxNQ==&mid=2247484238&idx=2&sn=932ffb22c0ac546207b4aa219340de99&channel_session_id=null&sessionid=svr_68a7a4fd499&scene=168&subscene=136#rd
