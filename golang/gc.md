## Go GC 垃圾回收机制

GC（Garbage Collection）是编程语言中提供的内存管理功能。

在C/C++中，声明一个变量意味着要在内存中申请一块内存，但内存是宝贵的，需要在不使用这个变量的时候释放掉这块内存，在C/C++中，需要程序员手动释放内存。

如果代码量大或者业务复杂，在开发中忘记释放内存或者释放了不该释放的内存，前者会造成资料浪费，内存泄漏，后者会发生不可预知的问题。

为了解决这个问题，后来新出的语言(java/python/golang)在语言层面实现了自动内存管理，由虚拟机或运行时来释放不再使用的内存，统称为垃圾回收。

## 垃圾回收常见算法

### 引用计数

引用计数通过在对象上增加自己被引用的次数，被其他对象引用时加1，引用自己的对象被回收时减1，引用数为0的对象即为可以被回收的对象。

优点：

- 方式简单，回收速度快

缺点：

- 需要额外的空间存放计数

- 无法处理循环引用

- 频繁更新引用计数降低了性能

### 标记-清除

分为两个步骤：

- 标记(Mark phase)

- 清除(Sweep phase)

第一步，找出可达的对象，然后做上标记。

第二步，回收未标记的对象

**需要注意的是，mark and sweep算法在执行的时候，需要程序暂停！即Stop The Wrold**

缺点：

- STW，stop the world; 让程序暂停，程序出现卡顿

- 标记需要扫描整个heap

- 清除数据会产生heap碎片

### 复制收集

节点复制也是基于追踪的算法。其将整个堆等分为两个半区（semi-space），一个包含现有数据，另一个包含已被废弃的数据。节点复制式垃圾收集从切换（flip）两个半区的角色开始，然后收集器在老的半区，也就是 Fromspace 中遍历存活的数据结构，在第一次访问某个单元时把它复制到新半区，也就是 Tospace 中去。在 Fromspace 中所有存活单元都被访问过之后，收集器在 Tospace 中建立一个存活数据结构的副本，用户程序可以重新开始运行了。

### 分代收集

基于追踪的垃圾回收算法（标记-清扫、节点复制）一个主要问题是在生命周期较长的对象上浪费时间（长生命周期的对象是不需要频繁扫描的）。同时，内存分配存在这么一个事实 “most object die young”。基于这两点，分代垃圾回收算法将对象按生命周期长短存放到堆上的两个（或者更多）区域，这些区域就是分代（generation）。对于新生代的区域的垃圾回收频率要明显高于老年代区域。

分配对象的时候从新生代里面分配，如果后面发现对象的生命周期较长，则将其移到老年代，这个过程叫做 promote。随着不断 promote，最后新生代的大小在整个堆的占用比例不会特别大。收集的时候集中主要精力在新生代就会相对来说效率更高，STW 时间也会更短。

### 三色标记算法

步骤：

1。 从灰色对象的集合中选择一个灰色对象并将其标记为黑色

2。 将黑色对象指向的所有对象都标记为灰色，保证该对象和该对象引用的对象都不会被回收

3。 重复上述两个步骤直到对象图中不存在灰色对象

1. 扫描操作和用户逻辑可以并发

写屏障机制： gc跑的过程中，可以监控对象的内存修改，并对对象进行重新标记。（实际上也是超短暂的stw，然后对对象进行标记）新生成的对象，一律标记未灰色。

2. 清除操作和用户逻辑可以并发

清除所有的白色对象，然后把未清除的对象（黑色/灰色）标为白色对象

参考：https://juejin.im/post/5c8525666fb9a049ea39c3e6
