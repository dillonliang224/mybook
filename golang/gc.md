## Go GC 垃圾回收机制

GC（Garbage Collection）是编程语言中提供的内存管理功能。

在C/C++中，声明一个变量意味着要在内存中申请一块内存，但内存是宝贵的，需要在不使用这个变量的时候释放掉这块内存，在C/C++中，需要程序员手动释放内存。

如果代码量大或者业务复杂，在开发中忘记释放内存或者释放了不该释放的内存，前者会造成资料浪费，内存泄漏，后者会发生不可预知的问题。

为了解决这个问题，后来新出的语言(java/python/golang)在语言层面实现了自动内存管理，由虚拟机或运行时来释放不再使用的内存，统称为垃圾回收。

## 垃圾回收常见算法

### 引用计数

引用计数通过在对象上增加自己被引用的次数，被其他对象引用时加1，引用自己的对象被回收时减1，引用数为0的对象即为可以被回收的对象。

优点：

- 方式简单，回收速度快

缺点：

- 需要额外的空间存放计数

- 无法处理循环引用

- 频繁更新引用计数降低了性能

### 标记-清除

分为两个步骤：

- 标记(Mark phase)

- 清除(Sweep phase)

第一步，找出可达的对象，然后做上标记。

第二步，回收未标记的对象

**需要注意的是，mark and sweep算法在执行的时候，需要程序暂停！即Stop The Wrold**

缺点：

- STW，stop the world; 让程序暂停，程序出现卡顿

- 标记需要扫描整个heap

- 清除数据会产生heap碎片



### 标记整理：

为了解决内存碎片问题而提出，在标记过程中，将对象尽可能整理到一块连续的内存上



### 复制收集

节点复制也是基于追踪的算法。其将整个堆等分为两个半区（semi-space），一个包含现有数据，另一个包含已被废弃的数据。节点复制式垃圾收集从切换（flip）两个半区的角色开始，然后收集器在老的半区，也就是 Fromspace 中遍历存活的数据结构，在第一次访问某个单元时把它复制到新半区，也就是 Tospace 中去。在 Fromspace 中所有存活单元都被访问过之后，收集器在 Tospace 中建立一个存活数据结构的副本，用户程序可以重新开始运行了。

### 分代收集

基于追踪的垃圾回收算法（标记-清扫、节点复制）一个主要问题是在生命周期较长的对象上浪费时间（长生命周期的对象是不需要频繁扫描的）。同时，内存分配存在这么一个事实 “most object die young”。基于这两点，分代垃圾回收算法将对象按生命周期长短存放到堆上的两个（或者更多）区域，这些区域就是分代（generation）。对于新生代的区域的垃圾回收频率要明显高于老年代区域。

分配对象的时候从新生代里面分配，如果后面发现对象的生命周期较长，则将其移到老年代，这个过程叫做 promote。随着不断 promote，最后新生代的大小在整个堆的占用比例不会特别大。收集的时候集中主要精力在新生代就会相对来说效率更高，STW 时间也会更短。

### 三色标记算法

步骤：

1。 从灰色对象的集合中选择一个灰色对象并将其标记为黑色

2。 将黑色对象指向的所有对象都标记为灰色，保证该对象和该对象引用的对象都不会被回收

3。 重复上述两个步骤直到对象图中不存在灰色对象

1. 扫描操作和用户逻辑可以并发

写屏障机制： gc跑的过程中，可以监控对象的内存修改，并对对象进行重新标记。（实际上也是超短暂的stw，然后对对象进行标记）新生成的对象，一律标记未灰色。

2. 清除操作和用户逻辑可以并发

清除所有的白色对象，然后把未清除的对象（黑色/灰色）标为白色对象

参考：https://juejin.im/post/5c8525666fb9a049ea39c3e6

---

## Golang GC

**Go的GC目前使用的是无分代（对象没有代际之分）、不整理（回收过程中不对对象进行移动与整理）、并发（与用户代码并发执行）的三色标记清扫算法。**



原因在于：

1. 对象整理的优势在于解决内存碎片问题以及“允许”使用顺序内存分配器。但Go运行时的分配算法基于tcmalloc，基本上没有碎片问题。并且顺序内存分配器在多线程的场景下并不适用。Go使用的是基于tcmalloc的现代内存分配算法，对对象进行整理不会带来实质性的性能提升。

2. 分代GC依赖分代假设，即 GC 将主要的回收目标放在新创建的对象上（存活时间短，更倾向于被回收），而非频繁检查所有对象。但 Go 的编译器会通过**逃逸分析**将大部分新生对象存储在栈上（栈直接被回收），只有那些需要长期存在的对象才会被分配到需要进行垃圾回收的堆中。也就是说，分代 GC 回收的那些存活时间短的对象在 Go 中是直接被分配到栈上，当 goroutine 死亡后栈也会被直接回收，不需要 GC 的参与，进而分代假设并没有带来直接优势。并且 Go 的垃圾回收器与用户代码并发执行，使得 STW 的时间与对象的代际、对象的 size 没有关系。Go 团队更关注于如何更好地让 GC 与用户代码并发执行（使用适当的 CPU 来执行垃圾回收），而非减少停顿时间这一单一目标上。



参考文献

[tcmalloc原理剖析(基于gperftools-2.1) - 小龙的博客 | XiaoLong's Blog](http://gao-xiao-long.github.io/2017/11/25/tcmalloc/)

https://golang.design/under-the-hood/zh-cn/part2runtime/ch08gc/basic/

https://qcrao91.gitbook.io/go/gc/gc



**根对象**包括全局变量、执行栈、寄存器

1。 先把根对象标记为灰色，然后遍历灰色对象，找到对它的引用，自身标记为黑色，找到的引用标记为灰色

2。 直到所有能找到的对象标记为黑色，未被标记为白色

3。 清除所有白色对象



值得注意的是，三色标记的过程，会启动写屏障，保证标记过程中新产生的对象不会被误回收掉。



### GC调优

开发过程中，遇到的GC问题有以下情况：

1。 对停顿敏感：GC过程中产生的长时间停顿、或由于需要执行GC而没有执行用户代码，导致需要立即执行的用户代码执行滞后

2。 对资源消耗敏感：对于频繁分配内存的应用而言，频繁分配内存增加GC的工作量，原本可以充分利用的CPU的应用不得不频繁地执行垃圾回收，影响用户代码对CPU的利用率，进而影响用户代码的执行效率



从上面两点看，所谓的GC调优的核心思想也就是充分的围绕上面的两点来展开：**优化内存的申请速度，尽可能的少申请内存**
