- channel实现

- 内存分配

- 可变函数

- 别名

- 切片截取第三个参数

- 基于类型创建的方法必须定义在同一个包内

- iota

- 不可寻址

### 原子操作CAS

原子操作cas在高并发的情况下，单次cas的执行成功率会降低，因此需要配合循环语句for，形成一个for+atmoc的类似自旋乐观锁的操作

原子操作主要由硬件提供支持，锁一般是由操作系统提供支持，比起直接使用锁，使用CAS这个过程不需要形成临界区和创建互斥量，所以会比使用锁更加高效。

## iota

iota是golang语言的常量计数器，只能在常量的表达式中使用

iota在const关键字出现时将被重置为0（const内部的第一行之前），const中每新增一行常量声明将使iota计数一次（iota可理解为const语句块中的行索引）

## 常量

常量组中如不指定类型和初始化值，则与上一行非空常量右值相同

```go
const (
     x uint16 = 120
     y
     s = "abc"
     z
 )
 func main() {
    fmt.Printf("%T %v\n", y, y) // uint16 120
    fmt.Printf("%T %v\n", z, z) // string abc
}
```



## Map

key定位过程

key 经过哈希计算后得到哈希值，共 64 个 bit 位（64位机，32位机就不讨论了，现在主流都是64位机），计算它到底要落在哪个桶时，只会用到最后 B 个 bit 位。还记得前面提到过的 B 吗？如果 B = 5，那么桶的数量，也就是 buckets 数组的长度是 2^5 = 32。

例如，现在有一个 key 经过哈希函数计算后，得到的哈希结果是：

```shell
 10010111 | 000011110110110010001111001010100010010110010101010 │ 01010
```

用最后的 5 个 bit 位，也就是 `01010`，值为 10，也就是 10 号桶。这个操作实际上就是取余操作，但是取余开销太大，所以代码实现上用的位操作代替。

再用哈希值的高 8 位，找到此 key 在 bucket 中的位置，这是在寻找已有的 key。最开始桶内还没有 key，新加入的 key 会找到第一个空位，放入。



扩容

1. 装载因子超过阀值，源码里定义的阀值是6.5

2. overflow的bucket数量过多
