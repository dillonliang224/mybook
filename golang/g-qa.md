- channel实现

- 内存分配

- 可变函数

- 别名

- 切片截取第三个参数

- 基于类型创建的方法必须定义在同一个包内

- iota

- 不可寻址

### 原子操作CAS

原子操作cas在高并发的情况下，单次cas的执行成功率会降低，因此需要配合循环语句for，形成一个for+atmoc的类似自旋乐观锁的操作

原子操作主要由硬件提供支持，锁一般是由操作系统提供支持，比起直接使用锁，使用CAS这个过程不需要形成临界区和创建互斥量，所以会比使用锁更加高效。

## iota

iota是golang语言的常量计数器，只能在常量的表达式中使用

iota在const关键字出现时将被重置为0（const内部的第一行之前），const中每新增一行常量声明将使iota计数一次（iota可理解为const语句块中的行索引）

## 常量

常量组中如不指定类型和初始化值，则与上一行非空常量右值相同

```go
const (
     x uint16 = 120
     y
     s = "abc"
     z
 )
 func main() {
    fmt.Printf("%T %v\n", y, y) // uint16 120
    fmt.Printf("%T %v\n", z, z) // string abc
}
```

## Map

key定位过程

key 经过哈希计算后得到哈希值，共 64 个 bit 位（64位机，32位机就不讨论了，现在主流都是64位机），计算它到底要落在哪个桶时，只会用到最后 B 个 bit 位。还记得前面提到过的 B 吗？如果 B = 5，那么桶的数量，也就是 buckets 数组的长度是 2^5 = 32。

例如，现在有一个 key 经过哈希函数计算后，得到的哈希结果是：

```shell
 10010111 | 000011110110110010001111001010100010010110010101010 │ 01010
```

用最后的 5 个 bit 位，也就是 `01010`，值为 10，也就是 10 号桶。这个操作实际上就是取余操作，但是取余开销太大，所以代码实现上用的位操作代替。

再用哈希值的高 8 位，找到此 key 在 bucket 中的位置，这是在寻找已有的 key。最开始桶内还没有 key，新加入的 key 会找到第一个空位，放入。

扩容

1. 装载因子超过阀值，源码里定义的阀值是6.5

2. overflow的bucket数量过多

## sysmon监控线程

这个线程未链接任何的P，这意味着调度器(scheduler)没有将其考虑在内，因此始终处于运行状态。

作用：

- 由应用程序创建的计时器(timer)。sysmon线程查看应该在运行却仍在等待*执行时间*的计时器。在这种情况下，Go将查看空闲的M和P列表，以便尽可能快地运行它们。

- 网络轮询器和系统调用。它将运行在网络操作中被阻塞的goroutine。

- 垃圾回收器（如果已经很长时间没有运行）。如果垃圾回收器已经2分钟没有运行，则sysmon将强制执行一轮垃圾回收（GC）

- 长时间运行的goroutine的抢占。任何运行时间超过**10毫秒**的goroutine都会被抢占，将运行时间(running time)留给其他goroutine

sysmon提供不保证的协程切换，一个协程运行超过10毫秒，如果没有其他的goroutine需要运行，不会发生协程切换。
