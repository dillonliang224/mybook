进程间的切换浪费CPU资源，用户态与内核态数据的拷贝

对于操作系统来说，进程和线程是一样的，结构体是一个task

P本地的G队列满了，新增的G放不进去，然后把P本地的G队列的前面一半打乱和新增的G一同放到全局G队列里去，为什么？ -- 来源于场景4 GMP

源码上是从P本地的G队列里去前面一半，汗，

从全局队列获取的个数（头部获取，加锁）

n = min(len(GQ) / GOMAXPROCS + 1, len(GQ/2))

从其他P队列偷取个数（尾部获取）

n = len(GQ/2)

自旋线程的最大限制：

自旋线程 + 执行线程 <= GOMAXPROCS

- goroutine调度的切换也不用陷入(trap)操作系统内核层完成
