## 逃逸分析

对于未发生逃逸的变量，直接在栈上分配内存，当函数返回时，栈上内存自动回收，因此能减小gc压力。

对逃逸的变量，会在堆上分配内存，函数返回时不回收内存，需要在gc的时候才能回收。

一个函数如果返回结构体而不返回指针，那会引起内存拷贝的开销。

注意：

golang的逃逸分析是在编译期完成的。

golang的逃逸分析只针对指针。一个值引用变量如果没有被取址，那么它永远不可能逃逸。

验证某个函数的变量是否发生逃逸的方法：

```go
go run -gcflags "-m -l" xxx.go
```

上面代码输出中，如果有如下两种情况，都表示发生逃逸

```go
moved to heap:xxx
xxx escapes to heap
```

### Case 1:

> 在某个函数中new或字面量创建出的变量，将其指针作为函数返回值，则该变量一定发生逃逸

### Case 2:

> 被已经逃逸的变量引用的指针，一定发生逃逸

### Case 3:

> 被指针类型的slice,map和chan引用的指针一定发生逃逸

```go
func main() {
    a := make([]*int, 1)
    b := 12
    a[0] = &b
}
```

必然不会逃逸的情况：

- 指针被未发生逃逸的变量引用

- 仅仅在函数内对变量做取址操作，而未将指针传出

有一些情况可能发生逃逸，也可能不发生逃逸：

- 分配一个大的内存超出了栈的限制，也会分配到堆上

- 将指针作为入参传给别的函数；这里还是要看指针在被传入的函数中的处理过程，如果发生了上边三种情况，则会逃逸；否则不会逃逸。





## 总结

1. 如何函数外部没有引用，则优先放到栈中（大内存还是放到堆中，超过了栈限制）

2. 如果函数外部存在引用，则必定放到堆中
