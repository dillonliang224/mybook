# Golang TODO

- 逃逸分析

- Golang Debug

- 垃圾回收
  



## 测试

> 人是否会进步以及进步得有多快，依赖的恰恰就是对自我的否定，这包括否定的深刻与否，以及否定自我的频率如何。这其实就是“不破不立”这个词表达的含义。 

### 规定

go语言对测试函数的名称和签名都有哪些规定？

- 对于功能测试函数来说，其名称必须以Test为前缀，并且参数列表中只应有一个*testing.T类型的参数声明。

- 对于性能测试函数来说，其名称必须以Benchmark为前缀，并且唯一参数的类型必须是*testing.B类型的。

- 对于示例测试函数来说，其名称必须以Example为前缀，但对函数的参数列表没有强制规定。

### 流程

go test命令在开始运行时，会先做一些准备工作，比如，确定内部需要用到的命令，检查我们指定的代码包或源码文件的有效性，以及判断我们给予的标记是否合法，等等。



在准备工作顺利完成之后，go test命令就会针对每个被测代码包，依次地进行构建、执行包中符合要求的测试函数，清理临时文件，打印测试结果。这就是通常情况下的主要测试流程。请注意上述的“依次”二字。对于每个被测代码包，go test命令会串行地执行测试流程中的每个步骤。



但是，为了加快测试速度，它通常会并发地对多个被测代码包进行功能测试，只不过，在最后打印测试结果的时候，它会依照我们给定的顺序逐个进行，这会让我们感觉到它是在完全串行地执行测试流程。



另一方面，由于并发的测试会让性能测试的结果存在偏差，所以性能测试一般都是串行进行的。更具体地说，只有在所有构建步骤都做完之后，go test命令才会真正地开始进行性能测试。



并且，下一个代码包性能测试的进行，总会等到上一个代码包性能测试的结果打印完成才会开始，而且性能测试函数的执行也都会是串行的。



### 框架

- testify



## strings

### 与string值相比，strings.Builder类型的值有哪些优势？

- 已存在的内容不可变，但可以拼接更多的内容(Write/WriteByte/WriteRune/WriteString)

- 减少了内存分配和内容拷贝的次数(copyCheck/Grow)

- 可将内容重置，可重用值。(Reset)

string类型的值是不可变的，对字符串的裁剪、拼接都会产生一个新的字符串。

你可以把这块内存的内容看成一个字节数组，而相应的string值则包含了指向字节数组头部的指针值。如此一来，我们在一个string值上应用切片表达式，就相当于在对其底层的字节数组做切片。

在进行字符串拼接的时候，Go语言会把所有被拼接的字符串依次拷贝到一个崭新且足够大的连续内存空间中，并把持有相应指针值的string值作为结果返回。

显然，当程序中存在过多的字符串拼接操作的时候，会对内存的分配产生非常大的压力。

###

### strings.Builder类型在使用上有约束吗？

- 在已被真正使用后就不可再被复制

- 由于其内容不是完全不可变的，所有需要使用方自行解决操作冲突和并发安全问题。

正是由于已使用的Builder值不能再被复制，所以肯定不会出现多个Builder值中的内容容器（也就是那个字节切片）共用一个底层字节数组的情况。这样也就避免了多个同源的Builder值在拼接内容时可能产生的冲突问题。

虽然已使用的Builder值不能再被复制，但是它的指针值却可以。无论什么时候，复制这个指针值，实际上指向的同一个Builder值。

###

### 为什么说strings.Reader类型的值可以高效地读取字符串？

因为在strings.Reader类型的值中，会保存已读取字节的计数，已读计数也代表者下次读取的起始索引位置，它也是读取回退和位置设定时的重要依据。

```go
var reader1 strings.Reader// 省略若干代码。
readingIndex := reader1.Size() - int64(reader1.Len()) // 计算出的已读计数。
```
