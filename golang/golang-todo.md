# Golang TODO

- 逃逸分析

- Golang Debug

- 垃圾回收

- go sync.Mutex

## 测试

> 人是否会进步以及进步得有多快，依赖的恰恰就是对自我的否定，这包括否定的深刻与否，以及否定自我的频率如何。这其实就是“不破不立”这个词表达的含义。 

### 规定

go语言对测试函数的名称和签名都有哪些规定？

- 对于功能测试函数来说，其名称必须以Test为前缀，并且参数列表中只应有一个*testing.T类型的参数声明。

- 对于性能测试函数来说，其名称必须以Benchmark为前缀，并且唯一参数的类型必须是*testing.B类型的。

- 对于示例测试函数来说，其名称必须以Example为前缀，但对函数的参数列表没有强制规定。

### 流程

go test命令在开始运行时，会先做一些准备工作，比如，确定内部需要用到的命令，检查我们指定的代码包或源码文件的有效性，以及判断我们给予的标记是否合法，等等。

在准备工作顺利完成之后，go test命令就会针对每个被测代码包，依次地进行构建、执行包中符合要求的测试函数，清理临时文件，打印测试结果。这就是通常情况下的主要测试流程。请注意上述的“依次”二字。对于每个被测代码包，go test命令会串行地执行测试流程中的每个步骤。

但是，为了加快测试速度，它通常会并发地对多个被测代码包进行功能测试，只不过，在最后打印测试结果的时候，它会依照我们给定的顺序逐个进行，这会让我们感觉到它是在完全串行地执行测试流程。

另一方面，由于并发的测试会让性能测试的结果存在偏差，所以性能测试一般都是串行进行的。更具体地说，只有在所有构建步骤都做完之后，go test命令才会真正地开始进行性能测试。

并且，下一个代码包性能测试的进行，总会等到上一个代码包性能测试的结果打印完成才会开始，而且性能测试函数的执行也都会是串行的。

### 框架

- testify

## strings

### 与string值相比，strings.Builder类型的值有哪些优势？

- 已存在的内容不可变，但可以拼接更多的内容(Write/WriteByte/WriteRune/WriteString)

- 减少了内存分配和内容拷贝的次数(copyCheck/Grow)

- 可将内容重置，可重用值。(Reset)

string类型的值是不可变的，对字符串的裁剪、拼接都会产生一个新的字符串。

你可以把这块内存的内容看成一个字节数组，而相应的string值则包含了指向字节数组头部的指针值。如此一来，我们在一个string值上应用切片表达式，就相当于在对其底层的字节数组做切片。

在进行字符串拼接的时候，Go语言会把所有被拼接的字符串依次拷贝到一个崭新且足够大的连续内存空间中，并把持有相应指针值的string值作为结果返回。

显然，当程序中存在过多的字符串拼接操作的时候，会对内存的分配产生非常大的压力。

###

### strings.Builder类型在使用上有约束吗？

- 在已被真正使用后就不可再被复制

- 由于其内容不是完全不可变的，所有需要使用方自行解决操作冲突和并发安全问题。

正是由于已使用的Builder值不能再被复制，所以肯定不会出现多个Builder值中的内容容器（也就是那个字节切片）共用一个底层字节数组的情况。这样也就避免了多个同源的Builder值在拼接内容时可能产生的冲突问题。

虽然已使用的Builder值不能再被复制，但是它的指针值却可以。无论什么时候，复制这个指针值，实际上指向的同一个Builder值。

###

### 为什么说strings.Reader类型的值可以高效地读取字符串？

因为在strings.Reader类型的值中，会保存已读取字节的计数，已读计数也代表者下次读取的起始索引位置，它也是读取回退和位置设定时的重要依据。

```go
var reader1 strings.Reader// 省略若干代码。
readingIndex := reader1.Size() - int64(reader1.Len()) // 计算出的已读计数。
```

## Sync同步

> 同步的用途有两个，一个是避免多个线程在同一时刻操作同一个数据块，另一个是协调多个线程，以避免它们在同一时刻执行同一个代码块。

同步其实就是在控制多个线程对共享资源的访问。

临界区总是需要受到同步工具保护的，否则就很可能会产生竟态条件。

![](https://static001.geekbang.org/resource/image/73/6c/73d3313640e62bb95855d40c988c2e6c.png)

### 互斥量mutex

一个互斥锁（互斥量）可以用来保护一个临界区（只要一个代码片段需要实现对共享资源的串行化访问，就可以被视为一个临界区）或者一组相关临界区，可以通过它来保证，在同一时刻只有一个goroutine处于该临界区之内。

为了兑换这个保证，每当有goroutine想进入临界区，都需要先对它进行锁定（Lock方法），并且，每个goroutine离开临界区时，都要及时地对它进行解锁（Unlock方法）。

### 使用互斥锁时有哪些注意事项？

- 不要重复锁定互斥锁

- 不要忘记解锁互斥锁，必要时使用defer语句

- 不要对尚未锁定或者已解锁对互斥锁解锁

- 不要在多个函数之间直接传递互斥锁

忘记解锁导致的panic与死锁导致的panic一样，都是无法恢复的。因此，我们总是应该保证，对于每一个操作，都要有且只有一个对应的解锁操作。

![](https://static001.geekbang.org/resource/image/4f/0d/4f86467d09ffca6e0c02602a9cb7480d.png)

最后，Go语言中的互斥锁是开箱即用的，是一个结构体类型，属于值类型中的一种。把它传给一个函数、将它从函数中返回、把它赋给其他变量、让它进入某个通道都会导致它的副本的产生。并且，原值和它的副本，以及多个副本之间都是完成独立的，它们都是不同的互斥锁。

### 读写锁与互斥锁有哪些异同？

读写锁是读/写互斥锁的简称。在Go语言中，读写锁由Sync.RWMutex类型的值代表，也是开箱即用的。

一个读写锁实际上包含了读锁和写锁。

- Lock方法和Unlock方法分别用于对写锁进行锁定和解锁

- RLock方法和RUnlock方法分别对读锁进行锁定和解锁

**对于某个受到读写锁保护的共享资源，多个写操作不能同时进行，写操作和读操作也不能同时进行，但多个读操作可以同时进行。**

对写锁进行解锁，会唤醒所有因试图锁定读锁，而被阻塞的goroutine，并且，这通常会使它们都成功完成对读锁的锁定。

然而，对读锁进行解锁，只会在没有其他读锁锁定的前提下，唤醒“因试图锁定写锁，而被阻塞的 goroutine”；并且，最终只会有一个被唤醒的 goroutine 能够成功完成对写锁的锁定，其他的 goroutine 还要在原处继续等待。至于是哪一个 goroutine，那就要看谁的等待时间最长了。

**可以通过RLocker()方法获取读锁**

**读写锁和互斥锁都实现了Locker接口**
